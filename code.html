<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>3f577799f77149388af5206a32516582</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<div class="cell markdown" id="LPk303PVeKWq">
<p>Here, I've implemented a DBSCAN model using python language from
scratch. Lets see how it works.</p>
<p>First, lets imports the libraries we want.</p>
</div>
<div class="cell code" data-execution_count="1" id="mFghvGqwBcm7">
<div class="sourceCode" id="cb1"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> matplotlib <span class="im">import</span> pyplot <span class="im">as</span> plt</span></code></pre></div>
</div>
<div class="cell markdown" id="j2ejNWEkeRnW">
The class below, is implemented to find the clusters using DBSCAN
algorithm. It has 6 methods:
<p>##<strong>init method:</strong>## This method initiates the
parameters of the class and does some preproseccing on the data you give
to it. The details are described in the code.</p>
<p>##<strong>is core method:</strong>## This method checks if the point
you passed to it is a core object or not. If it was a core object it
will store its neighbor objects on a dictionary called
neighbor_dict.</p>
<p>##<strong>preprocessing method:</strong>## This method finds the core
objects and their neighbors using the _is_core(self, d) method, before
the main methods are invoked.</p>
<p>##<strong>find neighbors method:</strong>## This method finds the
density reachable objects in a cluster.At first, you should give the
first core object of the cluster you want to find its data_points as the
parameter, then, the method will find other density reachable objects
inside that cluster using a recursive-dfs-like algorithm. The approach
is simple, it lables the points that are directly density reachable from
the core point you've specified on the parameter as points in one
cluster, and it will invoke the same method on other core objects which
are also directly density reachable from the core object in the
parameter. This way the method will find all the density reachable
objects in a cluster.</p>
<p>##<strong>fit method:</strong>## This method finds out how many
clusters there are and finds the points inside these clusters using the
self._find_neighbors(self, data_point) method.</p>
<p>##<strong>show clusters:</strong>## This method plots the clusters
AND the noises our model found. You should write the code snippet below
after you invoked this method:</p>
<pre><code>plt.legend()
plt.show()</code></pre>
<p>Note that you should use this method only after the fit() method.</p>
</div>
<div class="cell code" data-execution_count="64" id="DiIE960BCdsR">
<div class="sourceCode" id="cb3"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> DBSCAN:</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, eps, min_pts, data_set : np.array):</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span class="va">self</span>.eps <span class="op">=</span> eps</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    <span class="va">self</span>.min_pts <span class="op">=</span> min_pts</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    <span class="va">self</span>.cluster_num <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    <span class="va">self</span>.neighbor_dict <span class="op">=</span> {}</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    row_num <span class="op">=</span> data_set.shape[<span class="dv">0</span>]</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># add an extra column to see if a selected data point is a core object:</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    zero_column_for_core <span class="op">=</span> np.zeros((row_num, <span class="dv">1</span>))</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    data_set <span class="op">=</span> np.hstack((data_set, zero_column_for_core))</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># add an extra column to see if a selected data point is visited befor</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># (the find_neighbors function is invoked on this point or not):</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>    zero_column_for_visited <span class="op">=</span> np.zeros((row_num, <span class="dv">1</span>))</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>    data_set <span class="op">=</span> np.hstack((data_set, zero_column_for_visited))</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>    <span class="co"># add an extra column for cluster identification, minus 1 means the point is</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>    <span class="co"># a noise point and by default all points are noises:</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>    zero_column_for_clusers <span class="op">=</span> np.zeros((row_num, <span class="dv">1</span>)) <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>    <span class="va">self</span>.data_set <span class="op">=</span> np.hstack((data_set, zero_column_for_clusers))</span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>    <span class="co"># now lets determind the core objects and also their neighbors:</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>    <span class="va">self</span>._preprocessing()</span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>  <span class="co"># this method examins if a data_point is a core object based on eps and min_pts</span></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>  <span class="co"># and if it was a core object, the method stores its neighbor objects in a dictionary.</span></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> _is_core(<span class="va">self</span>, d):</span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>    neighbor_count <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>    neighbor_list <span class="op">=</span> []</span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> data <span class="kw">in</span> <span class="va">self</span>.data_set:</span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> np.linalg.norm(d[<span class="dv">0</span>:<span class="dv">2</span>] <span class="op">-</span> data[<span class="dv">0</span>:<span class="dv">2</span>]) <span class="op">&lt;=</span> <span class="va">self</span>.eps:</span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a>        neighbor_count <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a>        neighbor_list.append(data)</span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> neighbor_count <span class="op">&gt;=</span> <span class="va">self</span>.min_pts:</span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a>      <span class="va">self</span>.neighbor_dict[<span class="bu">tuple</span>(d[<span class="dv">0</span>:<span class="dv">2</span>])] <span class="op">=</span> neighbor_list</span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a>      d[<span class="op">-</span><span class="dv">3</span>] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb3-34"><a href="#cb3-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-35"><a href="#cb3-35" aria-hidden="true" tabindex="-1"></a>  <span class="co"># this method is invoked in the __init__ method to determind core objects and their neighbor objects for further use.</span></span>
<span id="cb3-36"><a href="#cb3-36" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> _preprocessing(<span class="va">self</span>):</span>
<span id="cb3-37"><a href="#cb3-37" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> data <span class="kw">in</span> <span class="va">self</span>.data_set:</span>
<span id="cb3-38"><a href="#cb3-38" aria-hidden="true" tabindex="-1"></a>      <span class="va">self</span>._is_core(data)</span>
<span id="cb3-39"><a href="#cb3-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-40"><a href="#cb3-40" aria-hidden="true" tabindex="-1"></a>  <span class="co"># this method is used to assign the cluster number to the density reachable objects which are reachable from a core object.</span></span>
<span id="cb3-41"><a href="#cb3-41" aria-hidden="true" tabindex="-1"></a>  <span class="co"># it is a recursive method which performs like dfs(in order to find density reachable objects).</span></span>
<span id="cb3-42"><a href="#cb3-42" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> _find_neighbors(<span class="va">self</span>, data_point):</span>
<span id="cb3-43"><a href="#cb3-43" aria-hidden="true" tabindex="-1"></a>    data_point[<span class="op">-</span><span class="dv">2</span>] <span class="op">=</span> <span class="dv">1</span> <span class="co"># it is visited from now on.</span></span>
<span id="cb3-44"><a href="#cb3-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-45"><a href="#cb3-45" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> data <span class="kw">in</span> <span class="va">self</span>.neighbor_dict[<span class="bu">tuple</span>(data_point[<span class="dv">0</span>:<span class="dv">2</span>])]:</span>
<span id="cb3-46"><a href="#cb3-46" aria-hidden="true" tabindex="-1"></a>      data[<span class="op">-</span><span class="dv">1</span>] <span class="op">=</span> <span class="va">self</span>.cluster_num</span>
<span id="cb3-47"><a href="#cb3-47" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> data[<span class="op">-</span><span class="dv">3</span>] <span class="op">==</span> <span class="dv">1</span> <span class="kw">and</span> data[<span class="op">-</span><span class="dv">2</span>] <span class="op">==</span> <span class="dv">0</span>: <span class="co"># if the point is core and it is not visited, so we should invoke the find_neighbor on it.</span></span>
<span id="cb3-48"><a href="#cb3-48" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>._find_neighbors(data)</span>
<span id="cb3-49"><a href="#cb3-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-50"><a href="#cb3-50" aria-hidden="true" tabindex="-1"></a>  <span class="co"># this method is used to find clusters and points within that cluster using DBSCAN algorithm.</span></span>
<span id="cb3-51"><a href="#cb3-51" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> fit(<span class="va">self</span>):</span>
<span id="cb3-52"><a href="#cb3-52" aria-hidden="true" tabindex="-1"></a>    cluster_exists <span class="op">=</span> <span class="va">True</span></span>
<span id="cb3-53"><a href="#cb3-53" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> cluster_exists:</span>
<span id="cb3-54"><a href="#cb3-54" aria-hidden="true" tabindex="-1"></a>      cluster_exists <span class="op">=</span> <span class="va">False</span></span>
<span id="cb3-55"><a href="#cb3-55" aria-hidden="true" tabindex="-1"></a>      <span class="cf">for</span> data_point <span class="kw">in</span> <span class="va">self</span>.data_set:</span>
<span id="cb3-56"><a href="#cb3-56" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> data_point[<span class="op">-</span><span class="dv">3</span>] <span class="op">==</span> <span class="dv">1</span>: <span class="co"># the point is a core point.</span></span>
<span id="cb3-57"><a href="#cb3-57" aria-hidden="true" tabindex="-1"></a>          <span class="cf">if</span> data_point[<span class="op">-</span><span class="dv">1</span>] <span class="op">==</span> <span class="op">-</span><span class="dv">1</span>: <span class="co"># then the point is not clustered yet and there still exists a cluster:</span></span>
<span id="cb3-58"><a href="#cb3-58" aria-hidden="true" tabindex="-1"></a>            cluster_exists <span class="op">=</span> <span class="va">True</span></span>
<span id="cb3-59"><a href="#cb3-59" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>._find_neighbors(data_point)</span>
<span id="cb3-60"><a href="#cb3-60" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.cluster_num <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb3-61"><a href="#cb3-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-62"><a href="#cb3-62" aria-hidden="true" tabindex="-1"></a>  <span class="co"># invoke this method only after the fit method is invoked.</span></span>
<span id="cb3-63"><a href="#cb3-63" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> show_clusters(<span class="va">self</span>):</span>
<span id="cb3-64"><a href="#cb3-64" aria-hidden="true" tabindex="-1"></a>    unique_labels <span class="op">=</span> np.unique(<span class="va">self</span>.data_set[:,<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb3-65"><a href="#cb3-65" aria-hidden="true" tabindex="-1"></a>    colors <span class="op">=</span> [<span class="st">&#39;red&#39;</span>, <span class="st">&#39;blue&#39;</span>, <span class="st">&#39;purple&#39;</span>, <span class="st">&#39;orange&#39;</span>]</span>
<span id="cb3-66"><a href="#cb3-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-67"><a href="#cb3-67" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> label, color <span class="kw">in</span> <span class="bu">zip</span>(unique_labels, colors):</span>
<span id="cb3-68"><a href="#cb3-68" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> label <span class="op">==</span> <span class="op">-</span><span class="dv">1</span>:</span>
<span id="cb3-69"><a href="#cb3-69" aria-hidden="true" tabindex="-1"></a>      <span class="co"># Points labeled as noise</span></span>
<span id="cb3-70"><a href="#cb3-70" aria-hidden="true" tabindex="-1"></a>        plt.scatter(<span class="va">self</span>.data_set[<span class="va">self</span>.data_set[:,<span class="op">-</span><span class="dv">1</span>] <span class="op">==</span> label, <span class="dv">0</span>], <span class="va">self</span>.data_set[<span class="va">self</span>.data_set[:,<span class="op">-</span><span class="dv">1</span>] <span class="op">==</span> label, <span class="dv">1</span>], color<span class="op">=</span><span class="st">&#39;black&#39;</span>, label<span class="op">=</span><span class="st">&#39;Noise&#39;</span>)</span>
<span id="cb3-71"><a href="#cb3-71" aria-hidden="true" tabindex="-1"></a>      <span class="cf">else</span>:</span>
<span id="cb3-72"><a href="#cb3-72" aria-hidden="true" tabindex="-1"></a>      <span class="co"># Points labeled with a cluster ID</span></span>
<span id="cb3-73"><a href="#cb3-73" aria-hidden="true" tabindex="-1"></a>        plt.scatter(<span class="va">self</span>.data_set[<span class="va">self</span>.data_set[:,<span class="op">-</span><span class="dv">1</span>] <span class="op">==</span> label, <span class="dv">0</span>], <span class="va">self</span>.data_set[<span class="va">self</span>.data_set[:,<span class="op">-</span><span class="dv">1</span>] <span class="op">==</span> label, <span class="dv">1</span>], color <span class="op">=</span> color, label<span class="op">=</span><span class="ss">f&#39;Cluster </span><span class="sc">{</span><span class="bu">int</span>(label)<span class="sc">}</span><span class="ss">&#39;</span>)</span>
<span id="cb3-74"><a href="#cb3-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-75"><a href="#cb3-75" aria-hidden="true" tabindex="-1"></a>    plt.title(<span class="ss">f&#39;</span><span class="sc">{</span><span class="bu">int</span>(<span class="bu">max</span>(unique_labels))<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss"> Clusters Found with eps: </span><span class="sc">{</span><span class="va">self</span><span class="sc">.</span>eps<span class="sc">}</span><span class="ss"> and minpts: </span><span class="sc">{</span><span class="va">self</span><span class="sc">.</span>min_pts<span class="sc">}</span><span class="ss">&#39;</span>)</span>
<span id="cb3-76"><a href="#cb3-76" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</div>
<div class="cell markdown" id="218xuIp4kFeI">
<p>Loading the data and plotting the data:</p>
</div>
<div class="cell code" data-execution_count="65"
data-colab="{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;,&quot;height&quot;:448}"
id="EiOW2wGOGpTC" data-outputId="5b1b1157-9e87-4811-fdd5-6e10bcbbe454">
<div class="sourceCode" id="cb4"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>d1 <span class="op">=</span> np.genfromtxt(<span class="st">&#39;d1.csv&#39;</span>, delimiter<span class="op">=</span><span class="st">&#39;,&#39;</span>)[<span class="dv">1</span>:]</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>plt.scatter(d1[:,<span class="dv">0</span>], d1[:,<span class="dv">1</span>])</span></code></pre></div>
<div class="output execute_result" data-execution_count="65">
<pre><code>&lt;matplotlib.collections.PathCollection at 0x7c08d5502890&gt;</code></pre>
</div>
<div class="output display_data">
<p><img
src="vertopal_42c0893622b34e2aa98b1c56df18f9ca/f9b4bd263aaeca2221e6c0c4be64e220427a1e15.png" /></p>
</div>
</div>
<div class="cell markdown" id="VTVeQr6gkK__">
<p>Now use the DBSCAN class to find clusters:</p>
</div>
<div class="cell code" data-execution_count="66"
data-colab="{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;,&quot;height&quot;:452}"
id="R6O6kdxbGxfZ" data-outputId="748b9e1a-1daf-4c2e-fe31-9531cbefbcc8">
<div class="sourceCode" id="cb6"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>eps, min_pts <span class="op">=</span> <span class="fl">0.15</span>, <span class="dv">5</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>dbscn <span class="op">=</span> DBSCAN(eps<span class="op">=</span>eps, min_pts<span class="op">=</span>min_pts, data_set<span class="op">=</span>d1)</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>dbscn.fit()</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>dbscn.show_clusters()</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code></pre></div>
<div class="output display_data">
<p><img
src="vertopal_42c0893622b34e2aa98b1c56df18f9ca/687a54accde9c0c5f311830c3075bbcb4e838640.png" /></p>
</div>
</div>
<div class="cell markdown" id="GraCBmEykQZ9">
<p>Lets test our DBSCAN class on another data set.</p>
</div>
<div class="cell code" data-execution_count="67"
data-colab="{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;,&quot;height&quot;:448}"
id="5O4PbnUlHoa8" data-outputId="c6225db2-9f00-4e84-8526-06fef8781254">
<div class="sourceCode" id="cb7"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>d2 <span class="op">=</span> np.genfromtxt(<span class="st">&#39;d2.csv&#39;</span>, delimiter<span class="op">=</span><span class="st">&#39;,&#39;</span>)[<span class="dv">1</span>:]</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>plt.scatter(d2[:,<span class="dv">0</span>], d2[:,<span class="dv">1</span>])</span></code></pre></div>
<div class="output execute_result" data-execution_count="67">
<pre><code>&lt;matplotlib.collections.PathCollection at 0x7c08da874730&gt;</code></pre>
</div>
<div class="output display_data">
<p><img
src="vertopal_42c0893622b34e2aa98b1c56df18f9ca/ae0e111323e65d15c1878c62ba408099ab24e530.png" /></p>
</div>
</div>
<div class="cell code" data-execution_count="68"
data-colab="{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;,&quot;height&quot;:452}"
id="6ipIDSQ9cNMn" data-outputId="f39a196b-a52b-4aad-beea-d1409e8cf981">
<div class="sourceCode" id="cb9"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>eps, min_pts <span class="op">=</span> <span class="fl">0.09</span>, <span class="dv">5</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>dbscn2 <span class="op">=</span> DBSCAN(eps<span class="op">=</span>eps, min_pts<span class="op">=</span>min_pts, data_set<span class="op">=</span>d2)</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>dbscn2.fit()</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>dbscn2.show_clusters()</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code></pre></div>
<div class="output display_data">
<p><img
src="vertopal_42c0893622b34e2aa98b1c56df18f9ca/7bf908c4ad60e82494c8afa06ff7083a99e8ee0a.png" /></p>
</div>
</div>
<div class="cell code" id="fcdSFKUCcXYI">
<div class="sourceCode" id="cb10"><pre
class="sourceCode python"><code class="sourceCode python"></code></pre></div>
</div>
</body>
</html>
